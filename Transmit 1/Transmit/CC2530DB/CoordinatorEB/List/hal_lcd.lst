###############################################################################
#                                                                             #
# IAR C/C++ Compiler V7.60.1.40026 for 8051             11/Jun/2011  21:22:42 #
# Copyright (C) 2004-2010 IAR Systems AB.                                     #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  D:\Texas Instruments\ZStack-CC2530-2.4.0-1.4.0\Com #
#                          ponents\hal\target\CC2530EB\hal_lcd.c              #
#    Command line       =  -f "D:\Texas Instruments\ZStack-CC2530-2.4.0-1.4.0 #
#                          \Projects\zstack\Utilities\Transmit\CC2530DB\..\.. #
#                          \..\Tools\CC2530DB\f8wCoord.cfg" (-DCPU32MHZ       #
#                          -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRU #
#                          E -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8       #
#                          -DMAC_CFG_RX_MAX=5 -DZDO_COORDINATOR -DRTR_NWK)    #
#                          -f "D:\Texas Instruments\ZStack-CC2530-2.4.0-1.4.0 #
#                          \Projects\zstack\Utilities\Transmit\CC2530DB\..\.. #
#                          \..\Tools\CC2530DB\f8wConfig.cfg" (-DZIGBEEPRO     #
#                          -DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR       #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DLINK_STATUS_JITTER_MASK=0x007F                   #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116                           #
#                          -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const     #
#                          __code" -DGENERIC=__generic                        #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000        #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)   #
#                          -DREJOIN_POLL_RATE=440 "D:\Texas                   #
#                          Instruments\ZStack-CC2530-2.4.0-1.4.0\Components\h #
#                          al\target\CC2530EB\hal_lcd.c" -D MT_TASK -D        #
#                          ZTOOL_P1 -D MT_SYS_FUNC -D MT_ZDO_FUNC -D          #
#                          LCD_SUPPORTED=DEBUG -D ZDNWKMGR_MIN_TRANSMISSIONS= #
#                          0 -lC "D:\Texas Instruments\ZStack-CC2530-2.4.0-1. #
#                          4.0\Projects\zstack\Utilities\Transmit\CC2530DB\Co #
#                          ordinatorEB\List\" -lA "D:\Texas                   #
#                          Instruments\ZStack-CC2530-2.4.0-1.4.0\Projects\zst #
#                          ack\Utilities\Transmit\CC2530DB\CoordinatorEB\List #
#                          \" --diag_suppress Pe001,Pa010 -o "D:\Texas        #
#                          Instruments\ZStack-CC2530-2.4.0-1.4.0\Projects\zst #
#                          ack\Utilities\Transmit\CC2530DB\CoordinatorEB\Obj\ #
#                          " -e --require_prototypes --no_code_motion         #
#                          --debug --core=plain --dptr=16,1                   #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data_rom --nr_virtual_regs 16    #
#                          -I "D:\Texas Instruments\ZStack-CC2530-2.4.0-1.4.0 #
#                          \Projects\zstack\Utilities\Transmit\CC2530DB\" -I  #
#                          "D:\Texas Instruments\ZStack-CC2530-2.4.0-1.4.0\Pr #
#                          ojects\zstack\Utilities\Transmit\CC2530DB\..\Sourc #
#                          e\" -I "D:\Texas Instruments\ZStack-CC2530-2.4.0-1 #
#                          .4.0\Projects\zstack\Utilities\Transmit\CC2530DB\. #
#                          .\..\..\ZMain\TI2530DB\" -I "D:\Texas              #
#                          Instruments\ZStack-CC2530-2.4.0-1.4.0\Projects\zst #
#                          ack\Utilities\Transmit\CC2530DB\..\..\..\..\..\Com #
#                          ponents\hal\include\" -I "D:\Texas                 #
#                          Instruments\ZStack-CC2530-2.4.0-1.4.0\Projects\zst #
#                          ack\Utilities\Transmit\CC2530DB\..\..\..\..\..\Com #
#                          ponents\hal\target\CC2530EB\" -I "D:\Texas         #
#                          Instruments\ZStack-CC2530-2.4.0-1.4.0\Projects\zst #
#                          ack\Utilities\Transmit\CC2530DB\..\..\..\..\..\Com #
#                          ponents\mac\include\" -I "D:\Texas                 #
#                          Instruments\ZStack-CC2530-2.4.0-1.4.0\Projects\zst #
#                          ack\Utilities\Transmit\CC2530DB\..\..\..\..\..\Com #
#                          ponents\mac\high_level\" -I "D:\Texas              #
#                          Instruments\ZStack-CC2530-2.4.0-1.4.0\Projects\zst #
#                          ack\Utilities\Transmit\CC2530DB\..\..\..\..\..\Com #
#                          ponents\mac\low_level\srf04\" -I "D:\Texas         #
#                          Instruments\ZStack-CC2530-2.4.0-1.4.0\Projects\zst #
#                          ack\Utilities\Transmit\CC2530DB\..\..\..\..\..\Com #
#                          ponents\mac\low_level\srf04\single_chip\" -I       #
#                          "D:\Texas Instruments\ZStack-CC2530-2.4.0-1.4.0\Pr #
#                          ojects\zstack\Utilities\Transmit\CC2530DB\..\..\.. #
#                          \..\..\Components\mt\" -I "D:\Texas                #
#                          Instruments\ZStack-CC2530-2.4.0-1.4.0\Projects\zst #
#                          ack\Utilities\Transmit\CC2530DB\..\..\..\..\..\Com #
#                          ponents\osal\include\" -I "D:\Texas                #
#                          Instruments\ZStack-CC2530-2.4.0-1.4.0\Projects\zst #
#                          ack\Utilities\Transmit\CC2530DB\..\..\..\..\..\Com #
#                          ponents\osal\mcu\ccsoc\" -I "D:\Texas              #
#                          Instruments\ZStack-CC2530-2.4.0-1.4.0\Projects\zst #
#                          ack\Utilities\Transmit\CC2530DB\..\..\..\..\..\Com #
#                          ponents\services\saddr\" -I "D:\Texas              #
#                          Instruments\ZStack-CC2530-2.4.0-1.4.0\Projects\zst #
#                          ack\Utilities\Transmit\CC2530DB\..\..\..\..\..\Com #
#                          ponents\services\sdata\" -I "D:\Texas              #
#                          Instruments\ZStack-CC2530-2.4.0-1.4.0\Projects\zst #
#                          ack\Utilities\Transmit\CC2530DB\..\..\..\..\..\Com #
#                          ponents\stack\af\" -I "D:\Texas                    #
#                          Instruments\ZStack-CC2530-2.4.0-1.4.0\Projects\zst #
#                          ack\Utilities\Transmit\CC2530DB\..\..\..\..\..\Com #
#                          ponents\stack\nwk\" -I "D:\Texas                   #
#                          Instruments\ZStack-CC2530-2.4.0-1.4.0\Projects\zst #
#                          ack\Utilities\Transmit\CC2530DB\..\..\..\..\..\Com #
#                          ponents\stack\sapi\" -I "D:\Texas                  #
#                          Instruments\ZStack-CC2530-2.4.0-1.4.0\Projects\zst #
#                          ack\Utilities\Transmit\CC2530DB\..\..\..\..\..\Com #
#                          ponents\stack\sec\" -I "D:\Texas                   #
#                          Instruments\ZStack-CC2530-2.4.0-1.4.0\Projects\zst #
#                          ack\Utilities\Transmit\CC2530DB\..\..\..\..\..\Com #
#                          ponents\stack\sys\" -I "D:\Texas                   #
#                          Instruments\ZStack-CC2530-2.4.0-1.4.0\Projects\zst #
#                          ack\Utilities\Transmit\CC2530DB\..\..\..\..\..\Com #
#                          ponents\stack\zdo\" -I "D:\Texas                   #
#                          Instruments\ZStack-CC2530-2.4.0-1.4.0\Projects\zst #
#                          ack\Utilities\Transmit\CC2530DB\..\..\..\..\..\Com #
#                          ponents\zmac\" -I "D:\Texas                        #
#                          Instruments\ZStack-CC2530-2.4.0-1.4.0\Projects\zst #
#                          ack\Utilities\Transmit\CC2530DB\..\..\..\..\..\Com #
#                          ponents\zmac\f8w\" -I "D:\Program Files\IAR        #
#                          Systems\Embedded Workbench 5.4\8051\INC\" -I       #
#                          "D:\Program Files\IAR Systems\Embedded Workbench   #
#                          5.4\8051\INC\CLIB\" -Ohz                           #
#    List file          =  D:\Texas Instruments\ZStack-CC2530-2.4.0-1.4.0\Pro #
#                          jects\zstack\Utilities\Transmit\CC2530DB\Coordinat #
#                          orEB\List\hal_lcd.lst                              #
#    Object file        =  D:\Texas Instruments\ZStack-CC2530-2.4.0-1.4.0\Pro #
#                          jects\zstack\Utilities\Transmit\CC2530DB\Coordinat #
#                          orEB\Obj\hal_lcd.r51                               #
#                                                                             #
#                                                                             #
###############################################################################

D:\Texas Instruments\ZStack-CC2530-2.4.0-1.4.0\Components\hal\target\CC2530EB\hal_lcd.c
      1          /**************************************************************************************************
      2            Filename:       hal_lcd.c
      3            Revised:        $Date: 2010-06-21 17:31:27 -0700 (Mon, 21 Jun 2010) $
      4            Revision:       $Revision: 22794 $
      5          
      6            Description:    This file contains the interface to the HAL LCD Service.
      7          
      8          
      9            Copyright 2007-2010 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS?WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /**************************************************************************************************
     41           *                                           INCLUDES
     42           **************************************************************************************************/
     43          #include "hal_types.h"
     44          #include "hal_lcd.h"
     45          #include "OSAL.h"
     46          #include "OnBoard.h"
     47          #include "hal_assert.h"
     48          
     49          #if defined (ZTOOL_P1) || defined (ZTOOL_P2)
     50            #include "DebugTrace.h"
     51          #endif
     52          
     53          /**************************************************************************************************
     54           *                                          CONSTANTS
     55           **************************************************************************************************/
     56          /*
     57            LCD pins
     58          
     59            //control
     60            P0.0 - LCD_MODE
     61            P1.1 - LCD_FLASH_RESET
     62            P1.2 - LCD_CS
     63          
     64            //spi
     65            P1.5 - CLK
     66            P1.6 - MOSI
     67            P1.7 - MISO
     68          */
     69          
     70          /* LCD Control lines */
     71          #define HAL_LCD_MODE_PORT 0
     72          #define HAL_LCD_MODE_PIN  0
     73          
     74          #define HAL_LCD_RESET_PORT 1
     75          #define HAL_LCD_RESET_PIN  1
     76          
     77          #define HAL_LCD_CS_PORT 1
     78          #define HAL_LCD_CS_PIN  2
     79          
     80          /* LCD SPI lines */
     81          #define HAL_LCD_CLK_PORT 1
     82          #define HAL_LCD_CLK_PIN  5
     83          
     84          #define HAL_LCD_MOSI_PORT 1
     85          #define HAL_LCD_MOSI_PIN  6
     86          
     87          #define HAL_LCD_MISO_PORT 1
     88          #define HAL_LCD_MISO_PIN  7
     89          
     90          /* SPI settings */
     91          #define HAL_SPI_CLOCK_POL_LO       0x00
     92          #define HAL_SPI_CLOCK_PHA_0        0x00
     93          #define HAL_SPI_TRANSFER_MSB_FIRST 0x20
     94          
     95          /* LCD lines */
     96          #define LCD_MAX_LINE_COUNT              3
     97          #define LCD_MAX_LINE_LENGTH             16
     98          #define LCD_MAX_BUF                     25
     99          
    100          /* Defines for HW LCD */
    101          
    102          /* Set power save mode */
    103          #define OSC_OFF                         0x00
    104          #define OSC_ON                          0x01
    105          #define POWER_SAVE_OFF                  0x00
    106          #define POWER_SAVE_ON                   0x02
    107          #define SET_POWER_SAVE_MODE(options)    HalLcd_HW_Control(0x0C | (options))
    108          
    109          /* Function Set */
    110          #define CGROM                           0x00
    111          #define CGRAM                           0x01
    112          #define COM_FORWARD                     0x00
    113          #define COM_BACKWARD                    0x02
    114          #define TWO_LINE                        0x00
    115          #define THREE_LINE                      0x04
    116          #define FUNCTION_SET(options)           HalLcd_HW_Control(0x10 | (options))
    117          
    118          /* Set Display Start Line */
    119          #define LINE1                           0x00
    120          #define LINE2                           0x01
    121          #define LINE3                           0x02
    122          #define LINE4                           0x03
    123          #define SET_DISPLAY_START_LINE(line)    HalLcd_HW_Control(0x18 | (line))
    124          
    125          /* Bias control */
    126          #define BIAS_1_5                        0x00
    127          #define BIAS_1_4                        0x01
    128          #define SET_BIAS_CTRL(bias)             HalLcd_HW_Control(0x1C | (bias))
    129          
    130          /* Power control */
    131          #define VOLTAGE_DIVIDER_OFF             0x00
    132          #define VOLTAGE_DIVIDER_ON              0x01
    133          #define CONVERTER_AND_REG_OFF           0x00
    134          #define CONVERTER_AND_REG_ON            0x04
    135          #define SET_POWER_CTRL(options)         HalLcd_HW_Control(0x20 | (options))
    136          
    137          // Set display control
    138          #define DISPLAY_CTRL_ON                 0x01
    139          #define DISPLAY_CTRL_OFF                0x00
    140          #define DISPLAY_CTRL_BLINK_ON           0x02
    141          #define DISPLAY_CTRL_BLINK_OFF          0x00
    142          #define DISPLAY_CTRL_CURSOR_ON          0x04
    143          #define DISPLAY_CTRL_CURSOR_OFF         0x00
    144          #define SET_DISPLAY_CTRL(options)       HalLcd_HW_Control(0x28 | (options))
    145          
    146          /* Set DD/ CGRAM address */
    147          #define SET_DDRAM_ADDR(charIndex)       HalLcd_HW_Control(0x80 | (charIndex))
    148          #define SET_GCRAM_CHAR(specIndex)       HalLcd_HW_Control(0xC0 | (specIndex))
    149          
    150          /* Set ICONRAM address */
    151          #define CONTRAST_CTRL_REGISTER          0x10
    152          #define SET_ICONRAM_ADDR(addr)          HalLcd_HW_Control(0x40 | (addr))
    153          
    154          /* Set double height */
    155          #define LINE_1_AND_2                    0x01
    156          #define LINE_2_AND_3                    0x02
    157          #define NORMAL_DISPLAY                  0x00
    158          #define SET_DOUBLE_HEIGHT(options)      HalLcd_HW_Control(0x08 | (options))
    159          
    160          /**************************************************************************************************
    161           *                                           MACROS
    162           **************************************************************************************************/
    163          
    164          #define HAL_IO_SET(port, pin, val)        HAL_IO_SET_PREP(port, pin, val)
    165          #define HAL_IO_SET_PREP(port, pin, val)   st( P##port##_##pin## = val; )
    166          
    167          #define HAL_CONFIG_IO_OUTPUT(port, pin, val)      HAL_CONFIG_IO_OUTPUT_PREP(port, pin, val)
    168          #define HAL_CONFIG_IO_OUTPUT_PREP(port, pin, val) st( P##port##SEL &= ~BV(pin); \
    169                                                                P##port##_##pin## = val; \
    170                                                                P##port##DIR |= BV(pin); )
    171          
    172          #define HAL_CONFIG_IO_PERIPHERAL(port, pin)      HAL_CONFIG_IO_PERIPHERAL_PREP(port, pin)
    173          #define HAL_CONFIG_IO_PERIPHERAL_PREP(port, pin) st( P##port##SEL |= BV(pin); )
    174          
    175          
    176          
    177          /* SPI interface control */
    178          #define LCD_SPI_BEGIN()     HAL_IO_SET(HAL_LCD_CS_PORT,  HAL_LCD_CS_PIN,  0); /* chip select */
    179          #define LCD_SPI_END()                                                         \
    180          {                                                                             \
    181            asm("NOP");                                                                 \
    182            asm("NOP");                                                                 \
    183            asm("NOP");                                                                 \
    184            asm("NOP");                                                                 \
    185            HAL_IO_SET(HAL_LCD_CS_PORT,  HAL_LCD_CS_PIN,  1); /* chip select */         \
    186          }
    187          /* clear the received and transmit byte status, write tx data to buffer, wait till transmit done */
    188          #define LCD_SPI_TX(x)                   { U1CSR &= ~(BV(2) | BV(1)); U1DBUF = x; while( !(U1CSR & BV(1)) ); }
    189          #define LCD_SPI_WAIT_RXRDY()            { while(!(U1CSR & BV(1))); }
    190          
    191          
    192          /* Control macros */
    193          #define LCD_DO_WRITE()        HAL_IO_SET(HAL_LCD_MODE_PORT,  HAL_LCD_MODE_PIN,  1);
    194          #define LCD_DO_CONTROL()      HAL_IO_SET(HAL_LCD_MODE_PORT,  HAL_LCD_MODE_PIN,  0);
    195          
    196          #define LCD_ACTIVATE_RESET()  HAL_IO_SET(HAL_LCD_RESET_PORT, HAL_LCD_RESET_PIN, 0);
    197          #define LCD_RELEASE_RESET()   HAL_IO_SET(HAL_LCD_RESET_PORT, HAL_LCD_RESET_PIN, 1);
    198          
    199          #if (HAL_LCD == TRUE)
    200          /**************************************************************************************************
    201           *                                       LOCAL VARIABLES
    202           **************************************************************************************************/
    203          
    204          static uint8 *Lcd_Line1;
    205          
    206          /**************************************************************************************************
    207           *                                       FUNCTIONS - API
    208           **************************************************************************************************/
    209          
    210          void HalLcd_HW_Init(void);
    211          void HalLcd_HW_WaitUs(uint16 i);
    212          void HalLcd_HW_Clear(void);
    213          void HalLcd_HW_ClearAllSpecChars(void);
    214          void HalLcd_HW_Control(uint8 cmd);
    215          void HalLcd_HW_Write(uint8 data);
    216          void HalLcd_HW_SetContrast(uint8 value);
    217          void HalLcd_HW_WriteChar(uint8 line, uint8 col, char text);
    218          void HalLcd_HW_WriteLine(uint8 line, const char *pText);
    219          #endif //LCD
    220          
    221          /**************************************************************************************************
    222           * @fn      HalLcdInit
    223           *
    224           * @brief   Initilize LCD Service
    225           *
    226           * @param   init - pointer to void that contains the initialized value
    227           *
    228           * @return  None
    229           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    230          void HalLcdInit(void)
   \                     HalLcdInit:
    231          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    232          #if (HAL_LCD == TRUE)
    233            Lcd_Line1 = NULL;
    234            HalLcd_HW_Init();
    235          #endif
    236          }
   \   000000   02....       LJMP    ?BRET
    237          
    238          /*************************************************************************************************
    239           *                    LCD EMULATION FUNCTIONS
    240           *
    241           * Some evaluation boards are equipped with Liquid Crystal Displays
    242           * (LCD) which may be used to display diagnostic information. These
    243           * functions provide LCD emulation, sending the diagnostic strings
    244           * to Z-Tool via the RS232 serial port. These functions are enabled
    245           * when the "LCD_SUPPORTED" compiler flag is placed in the makefile.
    246           *
    247           * Most applications update both lines (1 and 2) of the LCD whenever
    248           * text is posted to the device. This emulator assumes that line 1 is
    249           * updated first (saved locally) and the formatting and send operation
    250           * is triggered by receipt of line 2. Nothing will be transmitted if
    251           * only line 1 is updated.
    252           *
    253           *************************************************************************************************/
    254          
    255          
    256          /**************************************************************************************************
    257           * @fn      HalLcdWriteString
    258           *
    259           * @brief   Write a string to the LCD
    260           *
    261           * @param   str    - pointer to the string that will be displayed
    262           *          option - display options
    263           *
    264           * @return  None
    265           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    266          void HalLcdWriteString ( char *str, uint8 option)
   \                     HalLcdWriteString:
    267          {
   \   000000   74ED         MOV     A,#-0x13
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 19
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 0,R2
   \   000007   8B..         MOV     ?V0 + 1,R3
   \   000009   89..         MOV     ?V0 + 5,R1
    268          #if (HAL_LCD != TRUE)
    269          static uint8 *Lcd_Line1;
    270          #endif //HAL_LCD
    271          
    272            uint8 strLen = 0;
    273            uint8 totalLen = 0;
    274            uint8 *buf;
    275            uint8 tmpLen;
    276          
    277            if ( Lcd_Line1 == NULL )
   \   00000B   90....       MOV     DPTR,#??Lcd_Line1
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   7002         JNZ     ??HalLcdWriteString_0
   \   000011   A3           INC     DPTR
   \   000012   E0           MOVX    A,@DPTR
   \                     ??HalLcdWriteString_0:
   \   000013   7018         JNZ     ??HalLcdWriteString_1
    278            {
    279              Lcd_Line1 = osal_mem_alloc( HAL_LCD_MAX_CHARS+1 );
   \   000015                ; Setup parameters for call to function osal_mem_alloc
   \   000015   7A11         MOV     R2,#0x11
   \   000017   7B00         MOV     R3,#0x0
   \   000019   12....       LCALL   ??osal_mem_alloc?relay
   \   00001C   90....       MOV     DPTR,#??Lcd_Line1
   \   00001F   EA           MOV     A,R2
   \   000020   F0           MOVX    @DPTR,A
   \   000021   A3           INC     DPTR
   \   000022   EB           MOV     A,R3
   \   000023   F0           MOVX    @DPTR,A
    280              HalLcdWriteString( "TexasInstruments", 1 );
   \   000024                ; Setup parameters for call to function HalLcdWriteString
   \   000024   7901         MOV     R1,#0x1
   \   000026   7A..         MOV     R2,#(`?<Constant "TexasInstruments">` & 0xff)
   \   000028   7B..         MOV     R3,#((`?<Constant "TexasInstruments">` >> 8) & 0xff)
   \   00002A   12....       LCALL   ??HalLcdWriteString?relay
    281            }
    282          
    283            strLen = (uint8)osal_strlen( (char*)str );
   \                     ??HalLcdWriteString_1:
   \   00002D                ; Setup parameters for call to function osal_strlen
   \   00002D   AA..         MOV     R2,?V0 + 0
   \   00002F   AB..         MOV     R3,?V0 + 1
   \   000031   12....       LCALL   ??osal_strlen?relay
   \   000034   EA           MOV     A,R2
   \   000035   F5..         MOV     ?V0 + 4,A
    284          
    285            /* Check boundries */
    286            if ( strLen > HAL_LCD_MAX_CHARS )
   \   000037   C3           CLR     C
   \   000038   9411         SUBB    A,#0x11
   \   00003A   4003         JC      ??HalLcdWriteString_2
    287              strLen = HAL_LCD_MAX_CHARS;
   \   00003C   75..10       MOV     ?V0 + 4,#0x10
    288          
    289            if ( option == HAL_LCD_LINE_1 )
   \                     ??HalLcdWriteString_2:
   \   00003F   7401         MOV     A,#0x1
   \   000041   65..         XRL     A,?V0 + 5
   \   000043   7031         JNZ     ??HalLcdWriteString_3
    290            {
    291              /* Line 1 gets saved for later */
    292              osal_memcpy( Lcd_Line1, str, strLen );
   \   000045                ; Setup parameters for call to function osal_memcpy
   \   000045   75..00       MOV     ?V0 + 2,#0x0
   \   000048   78..         MOV     R0,#?V0 + 0
   \   00004A   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00004D   AC..         MOV     R4,?V0 + 4
   \   00004F   7D00         MOV     R5,#0x0
   \   000051   90....       MOV     DPTR,#??Lcd_Line1
   \   000054   E0           MOVX    A,@DPTR
   \   000055   FA           MOV     R2,A
   \   000056   A3           INC     DPTR
   \   000057   E0           MOVX    A,@DPTR
   \   000058   FB           MOV     R3,A
   \   000059   12....       LCALL   ??osal_memcpy?relay
   \   00005C   7403         MOV     A,#0x3
   \   00005E   12....       LCALL   ?DEALLOC_XSTACK8
    293              Lcd_Line1[strLen] = '\0';
   \   000061   A8..         MOV     R0,?V0 + 4
   \   000063   90....       MOV     DPTR,#??Lcd_Line1
   \   000066   E0           MOVX    A,@DPTR
   \   000067   28           ADD     A,R0
   \   000068   FA           MOV     R2,A
   \   000069   A3           INC     DPTR
   \   00006A   E0           MOVX    A,@DPTR
   \   00006B   3400         ADDC    A,#0x0
   \   00006D   8A82         MOV     DPL,R2
   \   00006F   F583         MOV     DPH,A
   \   000071   E4           CLR     A
   \   000072   F0           MOVX    @DPTR,A
   \   000073   02....       LJMP    ??HalLcdWriteString_4 & 0xFFFF
    294            }
    295            else
    296            {
    297              /* Line 2 triggers action */
    298              tmpLen = (uint8)osal_strlen( (char*)Lcd_Line1 );
   \                     ??HalLcdWriteString_3:
   \   000076                ; Setup parameters for call to function osal_strlen
   \   000076   90....       MOV     DPTR,#??Lcd_Line1
   \   000079   E0           MOVX    A,@DPTR
   \   00007A   FA           MOV     R2,A
   \   00007B   A3           INC     DPTR
   \   00007C   E0           MOVX    A,@DPTR
   \   00007D   FB           MOV     R3,A
   \   00007E   12....       LCALL   ??osal_strlen?relay
   \   000081   EA           MOV     A,R2
   \   000082   F5..         MOV     ?V0 + 2,A
    299              totalLen =  tmpLen + 1 + strLen + 1;
    300              buf = osal_mem_alloc( totalLen );
   \   000084                ; Setup parameters for call to function osal_mem_alloc
   \   000084   E5..         MOV     A,?V0 + 4
   \   000086   25..         ADD     A,?V0 + 2
   \   000088   2402         ADD     A,#0x2
   \   00008A   FA           MOV     R2,A
   \   00008B   7B00         MOV     R3,#0x0
   \   00008D   12....       LCALL   ??osal_mem_alloc?relay
   \   000090   8A..         MOV     ?V0 + 6,R2
   \   000092   8B..         MOV     ?V0 + 7,R3
   \   000094   AE..         MOV     R6,?V0 + 6
   \   000096   AF..         MOV     R7,?V0 + 7
    301              if ( buf != NULL )
   \   000098   EE           MOV     A,R6
   \   000099   7001         JNZ     ??HalLcdWriteString_5
   \   00009B   EF           MOV     A,R7
   \                     ??HalLcdWriteString_5:
   \   00009C   6076         JZ      ??HalLcdWriteString_4
    302              {
    303                /* Concatenate strings */
    304                osal_memcpy( buf, Lcd_Line1, tmpLen );
   \   00009E                ; Setup parameters for call to function osal_memcpy
   \   00009E   90....       MOV     DPTR,#??Lcd_Line1
   \   0000A1   E0           MOVX    A,@DPTR
   \   0000A2   F5..         MOV     ?V0 + 8,A
   \   0000A4   A3           INC     DPTR
   \   0000A5   E0           MOVX    A,@DPTR
   \   0000A6   F5..         MOV     ?V0 + 9,A
   \   0000A8   75..00       MOV     ?V0 + 10,#0x0
   \   0000AB   78..         MOV     R0,#?V0 + 8
   \   0000AD   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0000B0   AC..         MOV     R4,?V0 + 2
   \   0000B2   7D00         MOV     R5,#0x0
   \   0000B4   12....       LCALL   ??osal_memcpy?relay
   \   0000B7   7403         MOV     A,#0x3
   \   0000B9   12....       LCALL   ?DEALLOC_XSTACK8
    305                buf[tmpLen++] = ' ';
   \   0000BC   85....       MOV     ?V0 + 6,?V0 + 2
   \   0000BF   EE           MOV     A,R6
   \   0000C0   25..         ADD     A,?V0 + 6
   \   0000C2   F582         MOV     DPL,A
   \   0000C4   EF           MOV     A,R7
   \   0000C5   3400         ADDC    A,#0x0
   \   0000C7   F583         MOV     DPH,A
   \   0000C9   7420         MOV     A,#0x20
   \   0000CB   F0           MOVX    @DPTR,A
   \   0000CC   05..         INC     ?V0 + 2
    306                osal_memcpy( &buf[tmpLen], str, strLen );
   \   0000CE                ; Setup parameters for call to function osal_memcpy
   \   0000CE   85....       MOV     ?V0 + 8,?V0 + 0
   \   0000D1   85....       MOV     ?V0 + 9,?V0 + 1
   \   0000D4   78..         MOV     R0,#?V0 + 8
   \   0000D6   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0000D9   E5..         MOV     A,?V0 + 4
   \   0000DB   F5..         MOV     ?V0 + 0,A
   \   0000DD   FC           MOV     R4,A
   \   0000DE   7D00         MOV     R5,#0x0
   \   0000E0   EE           MOV     A,R6
   \   0000E1   25..         ADD     A,?V0 + 2
   \   0000E3   FA           MOV     R2,A
   \   0000E4   EF           MOV     A,R7
   \   0000E5   3400         ADDC    A,#0x0
   \   0000E7   FB           MOV     R3,A
   \   0000E8   12....       LCALL   ??osal_memcpy?relay
   \   0000EB   7403         MOV     A,#0x3
   \   0000ED   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000F0   E5..         MOV     A,?V0 + 0
   \   0000F2   25..         ADD     A,?V0 + 2
   \   0000F4   F8           MOV     R0,A
   \   0000F5   E4           CLR     A
   \   0000F6   3400         ADDC    A,#0x0
   \   0000F8   F9           MOV     R1,A
   \   0000F9   EE           MOV     A,R6
   \   0000FA   28           ADD     A,R0
   \   0000FB   F582         MOV     DPL,A
   \   0000FD   EF           MOV     A,R7
   \   0000FE   39           ADDC    A,R1
   \   0000FF   F583         MOV     DPH,A
   \   000101   E4           CLR     A
   \   000102   F0           MOVX    @DPTR,A
    307                buf[tmpLen+strLen] = '\0';
    308          
    309                /* Send it out */
    310          #if defined (ZTOOL_P1) || defined (ZTOOL_P2)
    311          
    312          #if defined(SERIAL_DEBUG_SUPPORTED)
    313                buf[tmpLen+strLen] = '\n';
   \   000103   740A         MOV     A,#0xa
   \   000105   F0           MOVX    @DPTR,A
    314                debug_str( (uint8*)buf );
   \   000106                ; Setup parameters for call to function debug_str
   \   000106   EE           MOV     A,R6
   \   000107   FA           MOV     R2,A
   \   000108   EF           MOV     A,R7
   \   000109   FB           MOV     R3,A
   \   00010A   12....       LCALL   ??debug_str?relay
    315          #endif //LCD_SUPPORTED
    316          
    317          #endif //ZTOOL_P1
    318          
    319                /* Free mem */
    320                osal_mem_free( buf );
   \   00010D                ; Setup parameters for call to function osal_mem_free
   \   00010D   EE           MOV     A,R6
   \   00010E   FA           MOV     R2,A
   \   00010F   EF           MOV     A,R7
   \   000110   FB           MOV     R3,A
   \   000111   12....       LCALL   ??osal_mem_free?relay
    321              }
    322            }
    323            
    324          #if (HAL_LCD == TRUE)
    325            /* Display the string */
    326            HalLcd_HW_WriteLine (option, str);
    327          #endif //HAL_LCD
    328          //  
    329          //#if defined(SERIAL_DEBUG_SUPPORTED)  
    330          //      debug_str( (uint8*)str );
    331          //      debug_str( "\n" );
    332          //#endif //LCD_SUPPORTED  
    333          }
   \                     ??HalLcdWriteString_4:
   \   000114   7F0B         MOV     R7,#0xb
   \   000116   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment XDATA_Z, align 1, keep-with-next
   \                     ??Lcd_Line1:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    334          
    335          /**************************************************************************************************
    336           * @fn      HalLcdWriteValue
    337           *
    338           * @brief   Write a value to the LCD
    339           *
    340           * @param   value  - value that will be displayed
    341           *          radix  - 8, 10, 16
    342           *          option - display options
    343           *
    344           * @return  None
    345           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    346          void HalLcdWriteValue ( uint32 value, const uint8 radix, uint8 option)
   \                     HalLcdWriteValue:
    347          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    348          #if (HAL_LCD == TRUE)
    349            uint8 buf[LCD_MAX_BUF];
    350          
    351            _ltoa( value, &buf[0], radix );
    352            HalLcdWriteString( (char*)buf, option );
    353          #endif
    354          }
   \   000000   02....       LJMP    ?BRET
    355          
    356          /**************************************************************************************************
    357           * @fn      HalLcdWriteScreen
    358           *
    359           * @brief   Write a value to the LCD
    360           *
    361           * @param   line1  - string that will be displayed on line 1
    362           *          line2  - string that will be displayed on line 2
    363           *
    364           * @return  None
    365           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    366          void HalLcdWriteScreen( char *line1, char *line2 )
   \                     HalLcdWriteScreen:
    367          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    368          #if (HAL_LCD == TRUE)
    369            HalLcdWriteString( line1, 1 );
    370            HalLcdWriteString( line2, 2 );
    371          #endif
    372          }
   \   000000   02....       LJMP    ?BRET
    373          
    374          /**************************************************************************************************
    375           * @fn      HalLcdWriteStringValue
    376           *
    377           * @brief   Write a string followed by a value to the LCD
    378           *
    379           * @param   title  - Title that will be displayed before the value
    380           *          value  - value
    381           *          format - redix
    382           *          line   - line number
    383           *
    384           * @return  None
    385           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    386          void HalLcdWriteStringValue( char *title, uint16 value, uint8 format, uint8 line )
   \                     HalLcdWriteStringValue:
    387          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    388          #if (HAL_LCD == TRUE)
    389            uint8 tmpLen;
    390            uint8 buf[LCD_MAX_BUF];
    391            uint32 err;
    392          
    393            tmpLen = (uint8)osal_strlen( (char*)title );
    394            osal_memcpy( buf, title, tmpLen );
    395            buf[tmpLen] = ' ';
    396            err = (uint32)(value);
    397            _ltoa( err, &buf[tmpLen+1], format );
    398            HalLcdWriteString( (char*)buf, line );		
    399          #endif
    400          }
   \   000000   02....       LJMP    ?BRET
    401          
    402          /**************************************************************************************************
    403           * @fn      HalLcdWriteStringValue
    404           *
    405           * @brief   Write a string followed by a value to the LCD
    406           *
    407           * @param   title   - Title that will be displayed before the value
    408           *          value1  - value #1
    409           *          format1 - redix of value #1
    410           *          value2  - value #2
    411           *          format2 - redix of value #2
    412           *          line    - line number
    413           *
    414           * @return  None
    415           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    416          void HalLcdWriteStringValueValue( char *title, uint16 value1, uint8 format1,
   \                     HalLcdWriteStringValueValue:
    417                                            uint16 value2, uint8 format2, uint8 line )
    418          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    419          
    420          #if (HAL_LCD == TRUE)
    421          
    422            uint8 tmpLen;
    423            uint8 buf[LCD_MAX_BUF];
    424            uint32 err;
    425          
    426            tmpLen = (uint8)osal_strlen( (char*)title );
    427            if ( tmpLen )
    428            {
    429              osal_memcpy( buf, title, tmpLen );
    430              buf[tmpLen++] = ' ';
    431            }
    432          
    433            err = (uint32)(value1);
    434            _ltoa( err, &buf[tmpLen], format1 );
    435            tmpLen = (uint8)osal_strlen( (char*)buf );
    436          
    437            buf[tmpLen++] = ',';
    438            buf[tmpLen++] = ' ';
    439            err = (uint32)(value2);
    440            _ltoa( err, &buf[tmpLen], format2 );
    441          
    442            HalLcdWriteString( (char *)buf, line );		
    443          
    444          #endif
    445          }
   \   000000   02....       LJMP    ?BRET
    446          
    447          /**************************************************************************************************
    448           * @fn      HalLcdDisplayPercentBar
    449           *
    450           * @brief   Display percentage bar on the LCD
    451           *
    452           * @param   title   -
    453           *          value   -
    454           *
    455           * @return  None
    456           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    457          void HalLcdDisplayPercentBar( char *title, uint8 value )
   \                     HalLcdDisplayPercentBar:
    458          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    459          #if (HAL_LCD == TRUE)
    460          
    461            uint8 percent;
    462            uint8 leftOver;
    463            uint8 buf[17];
    464            uint32 err;
    465            uint8 x;
    466          
    467            /* Write the title: */
    468            HalLcdWriteString( title, HAL_LCD_LINE_1 );
    469          
    470            if ( value > 100 )
    471              value = 100;
    472          
    473            /* convert to blocks */
    474            percent = (uint8)(value / 10);
    475            leftOver = (uint8)(value % 10);
    476          
    477            /* Make window */
    478            osal_memcpy( buf, "[          ]  ", 15 );
    479          
    480            for ( x = 0; x < percent; x ++ )
    481            {
    482              buf[1+x] = '>';
    483            }
    484          
    485            if ( leftOver >= 5 )
    486              buf[1+x] = '+';
    487          
    488            err = (uint32)value;
    489            _ltoa( err, (uint8*)&buf[13], 10 );
    490          
    491            HalLcdWriteString( (char*)buf, HAL_LCD_LINE_2 );
    492          
    493          #endif
    494          
    495          }
   \   000000   02....       LJMP    ?BRET

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalLcdInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalLcdInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalLcdWriteString?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalLcdWriteString

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalLcdWriteValue?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalLcdWriteValue

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalLcdWriteScreen?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalLcdWriteScreen

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalLcdWriteStringValue?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalLcdWriteStringValue

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalLcdWriteStringValueValue?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalLcdWriteStringValueValue

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalLcdDisplayPercentBar?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalLcdDisplayPercentBar

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "TexasInstruments">`:
   \   000000   54657861     DB "TexasInstruments"
   \            73496E73
   \            7472756D
   \            656E7473
   \            00      
    496          
    497          #if (HAL_LCD == TRUE)
    498          /**************************************************************************************************
    499           *                                    HARDWARE LCD
    500           **************************************************************************************************/
    501          
    502          /**************************************************************************************************
    503           * @fn      halLcd_ConfigIO
    504           *
    505           * @brief   Configure IO lines needed for LCD control.
    506           *
    507           * @param   None
    508           *
    509           * @return  None
    510           **************************************************************************************************/
    511          static void halLcd_ConfigIO(void)
    512          {
    513            /* GPIO configuration */
    514            HAL_CONFIG_IO_OUTPUT(HAL_LCD_MODE_PORT,  HAL_LCD_MODE_PIN,  1);
    515            HAL_CONFIG_IO_OUTPUT(HAL_LCD_RESET_PORT, HAL_LCD_RESET_PIN, 1);
    516            HAL_CONFIG_IO_OUTPUT(HAL_LCD_CS_PORT,    HAL_LCD_CS_PIN,    1);
    517          }
    518          
    519          /**************************************************************************************************
    520           * @fn      halLcd_ConfigSPI
    521           *
    522           * @brief   Configure SPI lines needed for talking to LCD.
    523           *
    524           * @param   None
    525           *
    526           * @return  None
    527           **************************************************************************************************/
    528          static void halLcd_ConfigSPI(void)
    529          {
    530            /* UART/SPI Peripheral configuration */
    531          
    532             uint8 baud_exponent;
    533             uint8 baud_mantissa;
    534          
    535            /* Set SPI on UART 1 alternative 2 */
    536            PERCFG |= 0x02;
    537          
    538            /* Configure clk, master out and master in lines */
    539            HAL_CONFIG_IO_PERIPHERAL(HAL_LCD_CLK_PORT,  HAL_LCD_CLK_PIN);
    540            HAL_CONFIG_IO_PERIPHERAL(HAL_LCD_MOSI_PORT, HAL_LCD_MOSI_PIN);
    541            HAL_CONFIG_IO_PERIPHERAL(HAL_LCD_MISO_PORT, HAL_LCD_MISO_PIN);
    542          
    543          
    544            /* Set SPI speed to 1 MHz (the values assume system clk of 32MHz)
    545             * Confirm on board that this results in 1MHz spi clk.
    546             */
    547            baud_exponent = 15;
    548            baud_mantissa =  0;
    549          
    550            /* Configure SPI */
    551            U1UCR  = 0x80;      /* Flush and goto IDLE state. 8-N-1. */
    552            U1CSR  = 0x00;      /* SPI mode, master. */
    553            U1GCR  = HAL_SPI_TRANSFER_MSB_FIRST | HAL_SPI_CLOCK_PHA_0 | HAL_SPI_CLOCK_POL_LO | baud_exponent;
    554            U1BAUD = baud_mantissa;
    555          }
    556          
    557          /**************************************************************************************************
    558           * @fn      HalLcd_HW_Init
    559           *
    560           * @brief   Initilize HW LCD Driver.
    561           *
    562           * @param   None
    563           *
    564           * @return  None
    565           **************************************************************************************************/
    566          void HalLcd_HW_Init(void)
    567          {
    568            /* Initialize LCD IO lines */
    569            halLcd_ConfigIO();
    570          
    571            /* Initialize SPI */
    572            halLcd_ConfigSPI();
    573          
    574            /* Perform reset */
    575            LCD_ACTIVATE_RESET();
    576            HalLcd_HW_WaitUs(15000); // 15 ms
    577            LCD_RELEASE_RESET();
    578            HalLcd_HW_WaitUs(15); // 15 us
    579          
    580            /* Perform the initialization sequence */
    581            FUNCTION_SET(CGRAM | COM_FORWARD | THREE_LINE);
    582          
    583            /* Set contrast */
    584            HalLcd_HW_SetContrast(15);
    585          
    586            /* Set power */
    587            SET_POWER_SAVE_MODE(OSC_OFF | POWER_SAVE_ON);
    588            SET_POWER_CTRL(VOLTAGE_DIVIDER_ON | CONVERTER_AND_REG_ON);
    589            SET_BIAS_CTRL(BIAS_1_5);
    590            HalLcd_HW_WaitUs(21000);// 21 ms
    591          
    592            /* Clear the display */
    593            HalLcd_HW_Clear();
    594            HalLcd_HW_ClearAllSpecChars();
    595            SET_DISPLAY_CTRL(DISPLAY_CTRL_ON | DISPLAY_CTRL_BLINK_OFF | DISPLAY_CTRL_CURSOR_OFF);
    596          }
    597          
    598          /**************************************************************************************************
    599           * @fn      HalLcd_HW_Control
    600           *
    601           * @brief   Write 1 command to the LCD
    602           *
    603           * @param   uint8 cmd - command to be written to the LCD
    604           *
    605           * @return  None
    606           **************************************************************************************************/
    607          void HalLcd_HW_Control(uint8 cmd)
    608          {
    609            LCD_SPI_BEGIN();
    610            LCD_DO_CONTROL();
    611            LCD_SPI_TX(cmd);
    612            LCD_SPI_WAIT_RXRDY();
    613            LCD_SPI_END();
    614          }
    615          
    616          /**************************************************************************************************
    617           * @fn      HalLcd_HW_Write
    618           *
    619           * @brief   Write 1 byte to the LCD
    620           *
    621           * @param   uint8 data - data to be written to the LCD
    622           *
    623           * @return  None
    624           **************************************************************************************************/
    625          void HalLcd_HW_Write(uint8 data)
    626          {
    627            LCD_SPI_BEGIN();
    628            LCD_DO_WRITE();
    629            LCD_SPI_TX(data);
    630            LCD_SPI_WAIT_RXRDY();
    631            LCD_SPI_END();
    632          }
    633          
    634          /**************************************************************************************************
    635           * @fn          HalLcd_HW_SetContrast
    636           *
    637           * @brief       Set display contrast
    638           *
    639           * @param       uint8 value - contrast value
    640           *
    641           * @return      none
    642           **************************************************************************************************/
    643          void HalLcd_HW_SetContrast(uint8 value)
    644          {
    645            SET_ICONRAM_ADDR(CONTRAST_CTRL_REGISTER);
    646            HalLcd_HW_Write(value);
    647          }
    648          
    649          /**************************************************************************************************
    650           * @fn      HalLcd_HW_Clear
    651           *
    652           * @brief   Clear the HW LCD
    653           *
    654           * @param   None
    655           *
    656           * @return  None
    657           **************************************************************************************************/
    658          void HalLcd_HW_Clear(void)
    659          {
    660            uint8 n;
    661          
    662            SET_DDRAM_ADDR(0x00);
    663            for (n = 0; n < (LCD_MAX_LINE_COUNT * LCD_MAX_LINE_LENGTH); n++)
    664            {
    665              HalLcd_HW_Write(' ');
    666            }
    667          }
    668          
    669          /**************************************************************************************************
    670           * @fn      HalLcd_HW_ClearAllSpecChars
    671           *
    672           * @brief   Clear all special chars
    673           *
    674           * @param   None
    675           *
    676           * @return  None
    677           **************************************************************************************************/
    678          void HalLcd_HW_ClearAllSpecChars(void)
    679          {
    680            uint8 n = 0;
    681          
    682            SET_GCRAM_CHAR(0);
    683            for (n = 0; n < (8 * 8); n++)
    684            {
    685              HalLcd_HW_Write(0x00);
    686            }
    687          }
    688          
    689          /**************************************************************************************************
    690           * @fn      HalLcd_HW_WriteChar
    691           *
    692           * @brief   Write one char to the display
    693           *
    694           * @param   uint8 line - line number that the char will be displayed
    695           *          uint8 col - colum where the char will be displayed
    696           *
    697           * @return  None
    698           **************************************************************************************************/
    699          void HalLcd_HW_WriteChar(uint8 line, uint8 col, char text)
    700          {
    701            if (col < LCD_MAX_LINE_LENGTH)
    702            {
    703              SET_DDRAM_ADDR((line - 1) * LCD_MAX_LINE_LENGTH + col);
    704              HalLcd_HW_Write(text);
    705            }
    706            else
    707            {
    708              return;
    709            }
    710          }
    711          
    712          /**************************************************************************************************
    713           * @fn          halLcdWriteLine
    714           *
    715           * @brief       Write one line on display
    716           *
    717           * @param       uint8 line - display line
    718           *              char *pText - text buffer to write
    719           *
    720           * @return      none
    721           **************************************************************************************************/
    722          void HalLcd_HW_WriteLine(uint8 line, const char *pText)
    723          {
    724            uint8 count;
    725            uint8 totalLength = (uint8)osal_strlen( (char *)pText );
    726          
    727            /* Write the content first */
    728            for (count=0; count<totalLength; count++)
    729            {
    730              HalLcd_HW_WriteChar(line, count, (*(pText++)));
    731            }
    732          
    733            /* Write blank spaces to rest of the line */
    734            for(count=totalLength; count<LCD_MAX_LINE_LENGTH;count++)
    735            {
    736              HalLcd_HW_WriteChar(line, count, ' ');
    737            }
    738          }
    739          
    740          /**************************************************************************************************
    741           * @fn      HalLcd_HW_WaitUs
    742           *
    743           * @brief   wait for x us. @ 32MHz MCU clock it takes 32 "nop"s for 1 us delay.
    744           *
    745           * @param   x us. range[0-65536]
    746           *
    747           * @return  None
    748           **************************************************************************************************/
    749          void HalLcd_HW_WaitUs(uint16 microSecs)
    750          {
    751            while(microSecs--)
    752            {
    753              /* 32 NOPs == 1 usecs */
    754              asm("nop"); asm("nop"); asm("nop"); asm("nop"); asm("nop");
    755              asm("nop"); asm("nop"); asm("nop"); asm("nop"); asm("nop");
    756              asm("nop"); asm("nop"); asm("nop"); asm("nop"); asm("nop");
    757              asm("nop"); asm("nop"); asm("nop"); asm("nop"); asm("nop");
    758              asm("nop"); asm("nop"); asm("nop"); asm("nop"); asm("nop");
    759              asm("nop"); asm("nop"); asm("nop"); asm("nop"); asm("nop");
    760              asm("nop"); asm("nop");
    761            }
    762          }
    763          #endif
    764          
    765          
    766          /**************************************************************************************************
    767          **************************************************************************************************/
    768          

   Maximum stack usage in bytes:

     Function                    ISTACK PSTACK XSTACK
     --------                    ------ ------ ------
     HalLcdDisplayPercentBar         0      0      0
     HalLcdInit                      0      0      0
     HalLcdWriteScreen               0      0      0
     HalLcdWriteString               1      0     41
       -> osal_mem_alloc             0      0     38
       -> HalLcdWriteString          0      0     38
       -> osal_strlen                0      0     38
       -> osal_memcpy                0      0     44
       -> osal_strlen                0      0     38
       -> osal_mem_alloc             0      0     38
       -> osal_memcpy                0      0     44
       -> osal_memcpy                0      0     44
       -> debug_str                  0      0     38
       -> osal_mem_free              0      0     38
     HalLcdWriteStringValue          0      0      1
     HalLcdWriteStringValueValue     0      0      4
     HalLcdWriteValue                0      0      1


   Segment part sizes:

     Function/Label                      Bytes
     --------------                      -----
     HalLcdInit                             3
     HalLcdWriteString                    281
     Lcd_Line1                              2
     HalLcdWriteValue                       3
     HalLcdWriteScreen                      3
     HalLcdWriteStringValue                 3
     HalLcdWriteStringValueValue            3
     HalLcdDisplayPercentBar                3
     ??HalLcdInit?relay                     6
     ??HalLcdWriteString?relay              6
     ??HalLcdWriteValue?relay               6
     ??HalLcdWriteScreen?relay              6
     ??HalLcdWriteStringValue?relay         6
     ??HalLcdWriteStringValueValue?relay    6
     ??HalLcdDisplayPercentBar?relay        6
     ?<Constant "TexasInstruments">        17

 
 299 bytes in segment BANKED_CODE
  42 bytes in segment BANK_RELAYS
  17 bytes in segment XDATA_ROM_C
   2 bytes in segment XDATA_Z
 
 341 bytes of CODE  memory
  17 bytes of CONST memory
   2 bytes of XDATA memory

Errors: none
Warnings: none
